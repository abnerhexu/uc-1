# 函数

在数学中，函数是我们再熟悉不过的事物了。输入一个数，得到某个结果，是一元函数给我们的最直观的印象。对于像$f(x)=\ln x$这样的函数，我们在计算器上只需要给定$x$，就能够得到相应的函数值，而无需关心其这个函数是如何计算得出结果的。在计算机中，函数不仅是针对数起作用，我们还可以依靠函数来对各种各样类型的数据进行处理，例如列表、元组和集合等。我们也在之前的编程实践中体会过，使用print()函数能够将我们需要打印的内容传递到显示屏幕上，而无需考虑这个函数是如何工作的。上面两个例子给了我们一些启示，即对于其他开发人员提供的函数，我们有时候不需要关心其内部结构，将其当作黑盒子处理；但是，在这一章中，我们需要就一些函数尤其地关心它们内部的实现方式，因为我们这一章的主题中很重要的内容就是实现那些我们习以为常的、认为开箱即用的函数。

### 2.1 实现数值计算的函数

总体而言，函数代码的结构大致是

```python
def func(x1, x2, x3):
  对变量操作的语句
  return y

```

关键字`def`指明了接下来的语句是某个函数，`func`是这个函数的名称，括号内标明传入函数的参数，紧接着在函数内，需要缩进代码语句。最后如果该函数有返回值，则需要有`return`语句；如果没有返回值则不需要。

例如，我们可以实现一个计算三角形周长的函数（我们假定传入的三个数字代表能构成三角形的三边长）。

```python
def length(a, b, c):
  return a+b+c

```

调用函数时，我们只需要传入相应的参数就可以了。

```python
print(length(3, 4, 5))
```

#### 2.1.1 通过泰勒公式计算数值

泰勒公式为我们提供了一个极其方便的办法来计算数值，其思路是通过多项式去逼近某个函数。例如，$\sin x$通过泰勒公式展开即为

$$
\sin x = x - \frac{x^3}{3!} +\frac{x^5}{5!} -\frac{x^7}{7!} +...
$$

写成泰勒级数的形式即为

$$
\sin x \sim  \sum_{n=0}^{\infty} (-1)^n \frac {x^{2n+1}}{(2n+1)!}
$$

通过取一定的项数，就能达到我们期望的精度值。例如，选取前50项，我们可以定义下面的函数来计算参数的正弦值。

```python
def factorial(x):
  ans = 1.0
  for i in range(1, x):
    ans *= i
  return ans

def sin(x):
  ans = 0
  for n in range(50):
    ans += (-1)**n*x**(2*n+1)/factorial(n)
  return ans

import math
print(sin(math.pi/48))
print(math.sin(math.pi/48))

```

从上面的代码中我们可以看到，一个函数内的操作是可以调用其他函数的。因此，我们在程序设计时，可以将特定的功能抽象得到函数，在具体运算中只需要调用函数就可以了。

我们的结果似乎与Python提供的答案有一定的差值；事实上，这是因为使用Maclaurin展开时，我们要求我们选取的$x$需要很靠近0，才能得到更精确的结果。

在之后的课程中，我们还会探究一个很重要的问题，那就是这样一段相同的代码，在不同的设备上可能运行得到不同的答案。到底哪一个是正确的？如何进行结果正确性的验证？这些我们都暂时按下不表，但读者可以先自行研究，相信在之后遇到这个问题时读者会有更深刻的印象。

#### 2.1.2 矩阵操作

尽管之后的章节中我们有更高性能和更方便的矩阵运算工具，但在这里，我们主要使用列表（和列表的嵌套）来模拟矩阵的运算。

> 🍈输入一个1×4的行向量$(x_1, x_2, x_3, x_4)$和一个4×2的矩阵$\begin{pmatrix} y_{11} & y_{12} 
>    \\y_{21} & y_{22} 
>    \\y_{31} & y_{32}
>    \\y_{41} & y_{42}
> \end{pmatrix}$，输出二者相乘的积。

> 🍈【线性代数的知识】两个矩阵$A$、$B$相乘，记作$C=AB$，那么$C$的行数与$A$相同，列数与$B$相同，且$C$的第$i$行第$j$列元素$C_{ij}$的值等于$A$的第$i$行这个向量与$B$的第$j$列这个向量的数量积。注意，只有当$A$的列数等于$B$的行数时，二者才可以做乘法运算。

在一点点线性代数知识的铺垫下，假设我们将这个行向量记作矩阵$A$，另一个矩阵记作$B$，得到结果的$C$矩阵应该是1行2列的一个矩阵。我们首先创建矩阵$C$用于存放结果，并把$C$中的每一个元素都赋值为0。

```python
C = [0, 0]

```

在相乘的过程中，我们需要用到两重循环。第一重循环，我们要将这个行向量与每一个列向量相乘，由于有两列，因此要循环两次；而在第一重循环的内部，我们需要第二重循环，这重循环用来解决某个行向量与列向量相乘时，对应的元素分别相乘并相加，由于每个向量的维度都是4维，所以要循环四次。因此，

```python
for i in range(2):
  tmp = 0
  for j in range(4):
    tmp += A[j]*B[j][i]
  C[i] = tmp

```

因此我们写出完整的代码如下所示。

```python
def dot(A, B):
  C = [0, 0]
  for i in range(2):
    tmp = 0
    for j in range(4):
      tmp += A[j]*B[j][i]
    C[i] = tmp
  print(C)

P = [1, 2, 3, 4]
Q = [[3, 4], [4, 5], [2, 1], [9, 0]]
dot(P, Q)
```

在这里有两个值得注意的问题。一是这个函数没有返回值，所以调用的时候只需要写上`dot(P, Q)`这个语句即可。二是这个函数在调用时，A和B已经确定了其矩阵规模，因此不能在传入参数的时候调换二者的位置，否则将出现错误；为了防止这个问题出现，我们可以在调用时写为`dot(A=P, B=Q)`，其中P和Q是程序中实际的两个矩阵的变量名。

现在，我们可以实现任意两个矩阵相乘的函数了。

> 🍈给定任意两个矩阵(元素均为整数，这两个矩阵能够相乘)，返回相乘后得到的矩阵。在这里我们约定如果这个矩阵是一个单行(或单列)向量，那么它们的组织形式依然是二位列表。例如，单行向量形如`matrix = [[1, 2, 3, 4]]`，而单列向量形如`matrix = [[1], [2], [3], [4]]`。

与上面的问题相比，实质上只需要多一层循环。现在，左侧的矩阵不止包含一行了，因此我们还要多加一个循环，让左边的每一行都去跟右边的每一列做内积。

```python
def dot(A, B):
    row = len(A)
    column = len(B[0])
    C = []
    for i in range(row):
        line = []
        for j in range(column):
            tmp = 0
            for k in range(len(B)):
                tmp += A[i][k]*B[k][j]
            line.append(tmp)
        C.append(line)
    return C

```

这里，我们没有提前定制矩阵C的大小，而是使用append方法，在每计算出一部分后都将其加入到矩阵C中。这样的可行性是由于我们的计算是按照i和j从小到大计算的，并且采取了同一行元素存放在同一个列表中的思路。

### 2.2 函数对自身的调用——递归

递归的本质是函数对自身的调用。在这一部分中，我们力争通过几个最简单的例子，讲述清楚函数递归在解决复杂问题中的独特优势，以及建立起通过递归解决问题的思维。

#### 2.2.1 爬楼梯

> 🍈小明爬楼梯，从第0级开始，每一次可以上升1级或2级。问：小明从第0级上到第20级可能的全部走法有多少种？

按照人类正向思维，我们会想从第0级开始逐个列举向上爬楼梯的各种可能；然而，如果只考虑小明是如何到达第20层的，显然只有两种可能：要么是从第18级上升2级到达，要么是从第19级上升1级到达。然后分别考虑第18级和第19级，显然也是类似的情况。因此我们只需要“倒过来”将所有的可能性相加。假设$F(n)$代表从第0级到第n级的所有可能走法，那么$F(n) = F(n-1) + F(n-2)$。

递归什么时候结束呢？按照上面的表达式，似乎随着n不断减少，甚至可以减少到0以下，这显然是不合理的，我们需要一个条件，当参数满足某种条件时，就结束递归。我们把递归结束的条件称为递归出口。显然，在这个问题中，如果n=1，那么只有一种情况；如果n=2，那么就有2种情况。这个函数需要两个递归出口，因为一开始我们就定义了开始向后递推的两个初始情况。现在我们可以来实现这个函数。

```python
def stairs(n):
  if n == 1:
      return 1
  if n == 2:
      return 2
  return stairs(n-1)+stairs(n-2)
```

初学者可能会有这样的疑问：为什么在第二个分支处不使用else if，以及为什么最后不需要else。事实上，函数在执行到return语句后就会结束之后的语句，因此，三者虽然在逻辑上是平行的，但写成代码时也可以采用如上所示的形式。

#### 2.2.2 斐波那契数列

斐波那契数列可能是最著名的数列之一。其源于这样的背景。

> 🍈一对小兔在出生两个月后开始繁衍，每个月剩下一对小兔。假设现在有一对刚出生的小兔，不考虑小兔死亡，求n个月后一共有多少对小兔？（n≥1）

我们现在已经有经验了，并且通过上面的案例已经明白了简单的递归问题只需要考虑三个方面：递归表达式、递归出口、递归目的。

递归的目的显然是求得兔子对数；递归表达式也容易看出，从第三个月开始，每个月的小兔数量都是前两个月之和；递归的出口是n=1和n=2时，即前两个月，兔子数量都是1对。

```python
def fib(n):
  if n == 1 or n == 2:
    return 1
  return fib(n-1)+fib(n-2)

```

#### 2.2.3 汉诺塔

汉诺塔起源于某个印度的神话，其大致背景是有A、B、C三根柱子，其中某一根（我们假定是A）柱子上放有$n$个自上而下从小到大排列的圆盘。依据下面的规则来移动圆盘：每次只移动一片圆盘；不论什么时候，小圆盘总是在大圆盘的上方。将这$n$个圆盘全部挪动到C柱子上，问需要挪动的总次数$m$。

对于许多在初高中学习时接触过算法竞赛(OI)的人来说，这恐怕是他们在学习程序设计时遇到的第一个需要花费一些时间思考的问题。显然，如果$n$=1，那么$m$=1；如果$n$=2，那么$m$=3。现在，我们来看$n$=3时的情况。

由于最大的盘子在A柱最底部，因此我们暂时忽略它的存在。现在，我们可以与之前$n$=2一样，将两个盘子移到柱B上。然后，我们将最大盘子移动到C；最后，我们又忽略最大盘子的存在，将在B上的盘子挪动到C上。

依此类推，有$n(n≥3)$个盘子时，我们首先将前$n-1$个盘子挪动到中间柱（第一步），然后将第$n$个盘子挪动到目标柱（第二步），再将前$n-1$个盘子从中间柱挪到目标柱（第三步）。至于第一步和第三步，当然就可以使用递归来解决。我们还容易发现的是，尽管我们为了方便理解，特意从n≥3开始介绍，但实际上n=2时，我们解决问题的方法也是如此。因此，递归出口只需要n=1即可。

```python
def hanoi():
  if n == 1:
    return 1
  return hanoi(n-1)+1+hanoi(n-1)

```

递推是一种自顶向下的算法，实际上是通过不停地调用或者间接调用自身的函数，实现对数值的不停计算，直到达到边界条件；其实现的核心是将较大的问题化归成较小的同类问题，即分治的策略。而递推是依据关系式，通过已知的条件和所要求的问题的解之间存在的某种关系进行一步一步的计算。

### 2.3 函数式编程简述

函数式编程是一种编程的方法论。在这种思想下，程序被细分为一个一个的函数，这样的函数只承担一项工作：接受输入，输出函数值。函数式编程具有一定的优势，例如其在形式证明、模块化与组合性方面更加擅长，同时更利于我们对程序进行调试。

事实上，函数式编程的核心在于排除函数的副作用，换言之，我们的函数应当是纯函数。函数存在的副作用，是指函数会影响超越函数本身的事物，例如函数可能会修改全局变量，进行IO操作等等。

纯函数具有的优势在编程实践中用处很大；这在之后我们会遇到。

#### 2.3.1 纯函数的基本原则

只做一件事，并把它做好。观察下面的例子A、B和C。

```python
# example A
var = 0
def func_a():
  global var
  var += 1
  return var

```

在例子A中，`func_a`不是一个纯函数，因为修改了全局变量`var`的值。在多次调用时，函数的返回值会变化。从这个意义上说，生成随机数的函数也不是纯函数，因为在不同的调用中，函数返回的值是不一样的。

```python
# example B
def hello():
  print("Hello!")
# example C
def hello_stateless():
  return "Hello!"

```

再例子B中，函数`hello`也不是一个纯函数。因为在这个函数中调用了非纯函数`print`。而`hello_stateless`就是一个纯函数。

显然，在我们有限的直觉中，计算机程序理所应当要读取数据、打印结果、与外界交互，这也是我们之前提到过的计算的构成要件。然而纯函数在抛弃了这些“副作用”之后，似乎就什么事情也完不成了？当然不是！函数式编程显然是不可避免地要使用到非纯函数的，这是由计算的必备要件所决定的；而函数式编程是让我们显式地将纯函数与非纯函数解耦合，更好地帮助我们提高了程序的模块性，我们也就能更好地写出正确的代码。

#### 2.3.2 迭代器

Python有一个非常有趣的语言特性，叫迭代器，它表示一个数据流对象，每次返回一个元素。例如，

```python
array = [0, 1, 2, 3, 4, 5]
it = iter(array) # 我们就得到了一个迭代器
for i in range(0, len(array)):
  print(it.__next__())
```

我们常常使用迭代器，但对于初学者来说却很少认识到这一点。Python编程中很多地方都可以使用到迭代器，例如在创建一个包含数字0~9的列表时，我们可以

```python
array = [x for x in range(10)]
```

对于任何可迭代的对象，我们都可以使用这样类似的语句。迭代器一般应用在两种场景中，一种是以遍历的方式对迭代器中的每一个元素进行相同操作；第二种是将满足某种要求的元素从迭代器中的全部元素中选出来。

```python
array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
array1 = [x+1 for x in array]
array2 = [x for x in array if x % 3 == 0]
```

#### 2.3.3 生成器

普通的函数，只能返回一个值（一次性返回的一个值，可能含有多个结果并被保存在一个元组中以元组的形式返回）；但对于生成器来说，它能返回一个数据流。可能这样描述对初学者来说稍显抽象，我们来看一个实际的案例。

```python
def ints(n, i = 0):
  while(i <= n):
    i += 1
    yield i
gen = ints(10)
while(1):
  print(gen.__next__())

```

有两个看起来有些奇怪的地方，第一个是`gen=ints(10)`，第二个是，这个函数居然可以通过`__next__()`的方法返回很多次。是的，Python中的函数与基本数据类型地位是相等的，你可以将一个函数赋值给某个变量；其次，这印证了我们刚刚所说的，通过生成器方法我们也能得到一系列的值。

#### 2.3.4 匿名函数lambda

有些函数是需要显式的表示的，例如我们之前遇到的所有函数；然而，匿名函数给予了我们更方便的、运用函数式编程思想来编写代码的方式。其基本写法是：

```python
lambda arguements: expression

```

同时，我们可以将定义的函数赋值给某个变量。例如，

```python
func = lambda x: min(x)
print(func([3,1,2]))
```

#### 2.3.5 避免循环的使用

听上去好像挺奇怪，但是我们确实不需要显式地写出循环了。例如，如果我们希望遍历某个列表，然后对列表中的每一个值都调用某个函数（可以是非纯函数），最后放进一个新的列表。传统的写法是

```python
lst = [(1, 2), (3, 5), (4, 6)]
res = []
for element in lst:
    res.append(min(element))
print(res)

```

现在，借用map，我们可以用一行代码解决问题。

```python
lst = [(1, 2), (3, 5), (4, 6)]
res = list(map(min, lst))
print(res)
```

当然，其实不加上`list()`也是可以的，但是如果只是写成`map(min, lst)`，那么res就将是一个生成器，而不是一个列表。

下一个场景，我们考虑遍历一个列表，对于列表内符合要求的元素就放入新的列表。我们可以用filter来完成。

```python
lst = [1, 2, 3, 5, 4, 6]
res = list(filter(lambda x: x % 2 == 0, lst))
print(res)

```

和map非常相似，在这里，我们向filter传入的第一个参数就是我们定义的lambda匿名函数。

我们来看一个较为复杂的案例，我们有这样一个数据结构：

```python
students = [{"name": "Alice", "score": 100},
            {"name": "Bob", "score": 98},
            {"name": "Cyan", "score": 100},
            {"name": "Dyan"}]

```

有些学生是有成绩的，有些学生是没有的。现在我们希望计算得出全部学生的平均分，对于没有分数的学生则不计算在内。

```python
score = list(map(lambda x: x["score"], filter(lambda y: "score" in y, students)))
average = sum(score)/len(score)
print(average)
```

函数式编程事实上为我们提供了这样一种编程范式：关心逻辑，把过程交给计算机。我们编写的代码交给计算机运行；我们显然不可能比计算机算得更快，但是我们在逻辑上抽象出的关系、任务、类型是计算机无法做到的。通过函数式编程，我们能借助更自然的思维模式来编写程序。
